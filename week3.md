# Week3

### Quest 1. ❓ **질문 방식 개선**

> AI와 대화하다 보면 추상적인 질문을 하는 경우가 많습니다.
> AI의 능력을 과신한 나머지 대화의 맥락을 모두 이해하고 있을 것이라고 오해하기 때문인데요.
> 정확한 맥락을 제공하지 않은 질문은 의도하지 않은 결과를 불러오는 경우가 많습니다.

이 퀘스트의 의도는 질문에 명확한 맥락을 제공하는 습관을 들이는 것입니다.
**내가 이해한 범위와 이해하지 못한 부분을 구체적인 키워드로 표현**하는 습관을 들여
AI를 학습에 도움이 되는 방향으로 사용하길 바라며 이 퀘스트를 제작했습니다.

>

- 설명
  - AI에게 질문할 때 **추상적인 표현을 피하고**, **내가 이해한 범위와 이해하지 못한 부분을 구체적인 키워드로 표현**하는 습관을 들인다.
- 수행 기준
  - [ ] 같은 주제로 AI에게 각각 2회(추상적/구체적) 질문을 작성한다.
  - [ ] 각 답변을 비교하여, 정확도나 만족도의 차이를 간단히 기록한다.

### Quest 2. 💛🐰🥕  당근과 채찍 🦔 🪢  🔫 🗡️ 😡 🪈 🩺  🏏🤷🏼

> 입에 쓴 약이 몸에 좋은 것처럼, 때로는 쓴소리와 같은 비판적인 피드백이 성장에 더 큰 도움이 될 때가 있습니다. 하지만 당근도 필요합니다.
>
> 긍정적인 피드백과 비판적인 피드백이 균형을 이뤄야 진정한 성장이 가능하다고 생각합니다.
>
> 이번 퀘스트에서는 ‘쓴 약’과 ‘당근’ 모두를 경험하며, **균형 잡힌 피드백**을 통해 성장하는 시간을 가져봅니다.

- 설명
  - 예시 프롬프트
    ```bash
    오늘 내가 참여한 대화나 활동을 바탕으로, 나에게 피드백을 줘.
    내가 잘한 점과 더 나아질 수 있는 부분을 균형 있게 알려줘.
    너무 추상적이지 않게 구체적인 예시와 함께 설명해줘.
    ```
- 수행 기준
  - [ ] AI의 피드백을 받아보고, 그 중에서 인상 깊었던 부분이나 실제로 적용하고 싶은 조언을 한 문장 이상 기록해보기

### Quest 3. 🎵 감정 기반 음악 추천 (README)

> 피어 피드백 시간에 다 함께 노래를 듣기보다는, **피어 컴파일링 시간에 작성한 리드미의 최상단에 전날 미션을 수행하며 느꼈던 감정을 바탕으로 AI에게 추천받은 음악을 첨부**하는 방식이 더 효과적일 수 있다고 생각했다.
>
> 이렇게 하면, 각자의 감정 상태를 자연스럽게 공유할 수 있고, **동료들이 리드미를 읽을 때 해당 곡과 함께 글쓴이의 감정에 더 몰입**할 수 있는 경험이 된다.
>
> 무엇보다, **피어 피드백 본연의 목적에 더 집중할 수 있는 시간 확보**에도 도움이 될 수 있다고 생각한다.

- 설명
  - 전날 미션을 수행하며 느낀 감정을 바탕으로 AI에게 음악을 추천 받아본다.
- 수행 기준
  - [ ] README 상단에 아래 내용을 추가한다.
    ```bash
    # Today's BGM
    <추천받은 BGM>
    ```

### Quest 4. 🗒️ AI를 활용한 피어 컴파일링 질문 대비하기

> 피어 컴파일링 과정에서 예상치 못한 질문을 받거나, 갑자기 질문을 던질 때 서로 당황했던 경험이 많았습니다.
>
> AI를 활용해 미리 나올 수 있는 질문을 준비한다면, 학습에 대한 깊이도 더해질 것이라고 생각합니다.
>
> 또한 피어 컴파일링 시간에 질문을 주고받는 것이 그 시간을 가장 알차게 활용하는 방법이라고 생각합니다.

- 설명
  - 내가 받을 수 있는 질문을 미리 대비해, 내 README(또는 학습 정리)를 준비해둡니다.
  - 준비한 README(또는 학습 정리)를 AI에게 제공합니다.
  - 예상 질문에 대한 답변을 먼저 직접 작성한 뒤, AI의 답변과 비교해봅니다.
- 수행 기준
  - [ ] 자신의 README(또는 학습 정리 문서)를 준비하고, AI에게 제공해서 질문을 3개이상 만들어보기
  - [ ] 예상 질문에 대해 먼저 직접 답변을 작성한 뒤, 동일한 질문에 대한 AI의 답변과 비교 해보기

---

# 기존 퀘스트 토론

- ✅ : 가져간 퀘스트
- ✳️ : 수정된 퀘스트
- ❎ : 교체된 퀘스트

## ✅ 퀘스트 1: 질문 방식 개선

- **내용**
  **📌 목표**
  AI에게 질문할 때 **추상적인 표현을 피하고**,
  **내가 이해한 범위와 이해하지 못한 부분을 구체적인 키워드로 표현**하는 습관을 들인다.
  **💡 예시**
  - ❌ "이 개념이 잘 이해가 안 돼요"
  - ✅ "멀티 스레드 개념까지는 이해했는데, 레이스 컨디션이 어떤 상황에서 발생하는지가 잘 이해되지 않습니다."

→ 퀘스트 내용은 가져가되, 퀘스트 수행 기준을 명확하게 제시한다.

## ✳️ 퀘스트 2: **나의 성장 추적**

- 내용
  **📌 목표**
  자주 사용하는 AI에게
  **어제와 비교해서 어떤 점이 나아졌는지 피드백**을 받아본다.
  **📌 방법**
  - 어제와 오늘의 질문/답변 내용을 스스로 정리한 후,
  - AI에게 비교 평가를 요청하고,
  - 그 피드백을 팀 슬랙에 공유한다.

→ 성장의 관점이 다양함 : 학습적인 성장? 정신적인 성장? 질문을 보다 구체적으로 할 수 있게 된 것도 성장이라고 볼 수 있다

## ✳️ 퀘스트 3: **감정 기반 음악 추천 + 피어 컴파일링**

- 내용
  **📌 목표**
  전날 미션을 수행하며 느꼈던 **감정을 바탕으로 AI에게 음악을 추천**받고,
  **피어 컴파일링 시작 전 5분간 '오늘의 곡'을 함께 듣는다.**
  **📌 활용 방식**
  1. "어제 미션을 하면서 느낀 감정은 ~였다"라고 AI에게 전달
  2. AI가 추천한 곡 중 하나를 선정
  3. 피어들과 함께 **집중 환경 조성용 BGM**으로 공유

→ 피어 피드백 시간이 생각보다 짧고 아쉬운 만큼 노래 듣는 시간이 가끔은 부담스럽고 아깝게 느껴지는 경우가 있다.

→ 변경된 방향 : README 맨 위에 감정과 BGM을 추가한다.

## ❎ 퀘스트 4: **챌린지 응원 메시지 공유**

- 내용
  **📌 목표**
  챌린지 기간 동안 서로를 격려하고 지지하기 위해,
  **AI에게 응원의 한마디를 받아 슬랙에 공유한다.**
  **📌 방법**
  - "챌린지 중인 나를 위해 한마디 응원해줘"라고 AI에게 요청
  - 받은 문장을 슬랙에 공유하여 **서로의 마음에 응원 에너지 불어넣기**
  - 일단, 전반적으로 퀘스트 수행 기준이 없어서 아쉬움

→ 응원 메시지는 슬랙에 이미 비슷한 내용이 반복적으로 공유되고 있어, 실제로는 큰 도움이 되지 않는다고 느껴 이번 미션에서는 제외했다.

→ 대신 피어 세션에서 급작스러운 질문을 받을 때 당황하는 것을 예방하기 위해 질문 예상 노트를 준비해서 대비하는 것으로 변경했다.

---

## 미션 수행

### K011

선택한 미션 : Quest 3. 🎵 감정 기반 음악 추천 (README)
선택한 이유 : 아침에 코드를 보거나 README를 읽으면 집중이 잘 되지 않을 때가 종종 있는데, 이 퀘스트를 통해서 팀원분들의 집중력도 높일 수 있고 수행하면서 좋은 추억도 가져갈 수 있을 것 같아서 선택하게 되었습니다.

<details>
    <summary>수행과정 </summary>
</details>

### J299

선택한 미션 : Quest 4. AI를 활용한 피어 컴파일링 질문 대비하기
선택한 이유 : 이번 미션을 수행하면서 방대한 양을 구현하고 학습했습니다. 이에 예상 질문을 추려서 다시 한번 복기해보기 위해 선택했습니다.

<details>
    <summary>수행과정</summary>
질문 1

“캠퍼와 MD 세션을 관리하는 구조를 나중에 변경하셨는데, 어떤 문제 때문에 기존 구조를 포기하게 되었고, 최종 구조의 장점은 무엇인가요?”

내 답변

기존에는 클라이언트 프로그램을 시작하면서 MD용 혹은 캠퍼용을 설정해야 한다고 생각했습니다. 두 모드에 따라 사용할 수 있는 커맨드가 매우 다르기에 애초에 분리해서 구현하자고 생각했습니다. 하지만 구현하면서 이 구조가 굳이 필요한가 의문이 들었습니다. 패킷을 받았을 때 권한이 없는 경우나 처리할 수 없는 경우를 위해서 결과 코드를 모두 작성해놨기 때문입니다. 최종 구조로 설계하고 나니 불필요한 초기 세팅 로직을 제거할 수 있었습니다.

AI 답변

초기에는 SessionManager에서 캠퍼 세션은 Map<camperId, session>, MD 세션은 단일 변수로 관리했습니다. 이 구조는 캠퍼는 여러 명이 접속 가능하고 MD는 한 명만 접속 가능하다는 요구사항을 만족하는 듯 보였지만, 다음과 같은 문제가 있었습니다.
캠퍼도 로그인 이전까지는 camperId가 없기 때문에, 세션을 관리할 수 없었습니다.
MD 세션은 인증 전에도 연결되어 있는 상태일 수 있는데, 인증 전에 단순히 연결만 된 상태를 구분할 방법이 없었습니다.
무작정 MD 모드를 막아버리면, 보안상 타이밍 유추가 가능하다는 피드백을 받았습니다.
이 문제를 해결하기 위해 모든 연결된 세션을 sessionId 기준으로 관리하도록 구조를 변경했습니다.
로그인/인증 여부와 상관없이 세션을 먼저 생성해 관리하고,
인증 성공 이후에만 해당 세션을 특정 역할(캠퍼 또는 MD)로 전환합니다.
또한, 모든 세션에 대해 고유한 sessionId를 부여하여 추적성을 확보했습니다.
장점은 다음과 같습니다:
캠퍼, MD, 인증 전 상태 모두를 일관되게 관리 가능
보안적으로 접속 타이밍 유출 방지
세션 타입만 바꾸면 되므로 불필요한 클래스 분기도 제거 가능
클라이언트의 상태 추적 및 유효성 검증이 쉬워짐

질문 2

“클라이언트에서 수신한 데이터의 타입에 따라 이벤트 핸들링을 분기할 때 switch문 대신 EventEmitter를 사용하신 이유는 무엇인가요?”

내 답변

분기문을 사용할 경우 이벤트 헨들링 로직을 작성하는 것 뿐만 아니라 연관된 모든 모듈 혹은 클래스에 추가 분기문을 작성해야 하기 때문입니다. 이는 어떤 사이드 이펙트를 일으킬 지 예상할 수 없으며 업데이트 시 추가로 배포해야할 프로그램이 많아지는 결과로 이어집니다. EventEmitter를 사용할 경우 디버깅이 어려워지는 단점이 존재하지만, 기존 구조를 건드리지 않고 확장할 수 있다는 매우 큰 장점이 있기에 이를 사용했습니다.

AI 답변

처음엔 수신된 패킷의 타입을 기준으로 if 또는 switch 문으로 처리하려 했습니다. 그러나 이 방식은 다음과 같은 문제를 동반합니다:
핸들러가 추가될 때마다 분기문이 길어지고,
새로운 패킷을 처리하려면 클라이언트의 로직 전체를 수정해야 합니다.
그래서 이벤트 기반(Event-driven) 아키텍처를 도입하여, type에 해당하는 이벤트를 EventEmitter로 전달하고,
그 이벤트를 CamperEventHandler 또는 MdEventHandler 클래스에서 등록하여 처리하도록 설계했습니다.
이 설계의 장점은 다음과 같습니다:
패킷 종류가 늘어나도 분기문 수정 없이 handler만 추가하면 됨
소켓 수신 → 이벤트 발행 → 핸들러 실행으로 책임 분리가 명확
재사용성과 테스트 용이성 증가
특히 캠퍼와 MD가 서로 다른 핸들러를 가질 수 있으므로 확장성이 뛰어남
또한 실제 게임 서버나 실시간 시스템에서도 자주 쓰이는 패턴이기에, 학습 겸 도입해봤습니다.

질문 3

“입력창과 로그 출력이 겹치는 문제를 해결하기 위해 safeLog()와 같은 유틸리티 함수를 구현하셨는데, 어떤 원리로 입력 상태를 유지하면서 출력을 관리할 수 있었나요?”

내 답변

`readline.input.on`을 통해 사용자가 프롬프트에 데이터를 입력할 때마다 이를 변수에 저장하도록 이벤트를 연결합니다. 이후 `console.log`로 출력해야하는 상황이 오면 입력 버퍼에 저장된 데이터를 제거하고 필요한 메시지를 출력합니다. 이후 `readline.clearLine`을 통해 라인을 정리한 다음 해당 위치로 `readline.cursorTo`를 사용하여 커서를 옮기고 기존에 저장해놨던 데이터를 다시 작성하는 방식을 사용했습니다.

AI 답변

Node.js에서 readline 모듈을 사용해 사용자 입력을 받고 있었는데, 비동기적으로 로그가 출력될 경우 입력란과 겹치는 문제가 있었습니다.
예를 들어 사용자가 아직 입력을 끝내지 않았는데, 서버에서 "로그인 성공" 로그가 출력되면 입력창이 밀리거나 가려졌습니다.
이를 해결하기 위해 safeLog()라는 유틸리티 함수를 만들었습니다. 작동 원리는 다음과 같습니다:
현재 readline 인터페이스가 열려 있는지 확인
열려 있다면:
readline.clearLine()으로 현재 줄의 내용을 지우고
readline.cursorTo(0)으로 커서를 줄 맨 앞으로 이동시킵니다
그 다음 로그를 console.log()로 출력하고
다시 프롬프트를 출력하고 process.stdout.write()로 이전 입력 내용을 복원합니다
이렇게 하면 입력창이 유지된 채로 로그가 출력되기 때문에 사용자 경험이 크게 향상됩니다.
또한 입력을 받는 부분도 일반적인 on("line")이 아닌 await getCommandInput()으로 조건부 입력을 구현해,
명확한 흐름 제어와 입력 양식 검증까지 가능하게 만들었습니다.

AI를 활용한 미션인 만큼 두 답변을 비교하는 것도 AI로 수행해봤습니다.

```
당신의 답변은 실제 구현 경험에서 우러나오는 생생함과 논리적인 흐름이 강점입니다. 제 답변은 "기술적 배경 + 아키텍처 시야"를 강조했기 때문에, 두 답변을 조화롭게 결합하면 면접에서도 매우 강력한 답변이 될 수 있습니다.
```

제 답변은 경험에 치중되어 있어 상대방이 들었을 때 논리적이지 못하다고 생각될 수 있겠습니다. 피어 피드백 시간에 답변할 때 "왜 그렇게 했는지"에 대해 좀 더 고민하고 들어가야겠다고 생각했습니다.

</details>

### J157

선택한 미션 : Quest 2. 🥕 당근과 채찍

선택한 이유 : 성장에는 객관적인 시선이 필요하다고 느꼈기 떄문에 저 혼자서는 보지 못하는 강점과 약점을 균형 있게 점검하고, 구체적인 피드백을 통해 더 나은 방향으로 나아가보고 싶어서 선택하였습니다

<details>
    <summary>수행과정 </summary>

### 질문

- 다음과 같이 예시 프롬프트 그대로 적용해 보았습니다

```
오늘 내가 참여한 대화나 활동을 바탕으로, 나에게 피드백을 줘.
내가 잘한 점과 더 나아질 수 있는 부분을 균형 있게 알려줘.
너무 추상적이지 않게 구체적인 예시와 함께 설명해줘.
```

### 답변

오늘 대화를 통해 살펴본 당신의 개발 과정을 분석하여 피드백을 드리겠습니다.

## **🌟 잘한 점들**

### **1. 설계 단계에서의 체계적 접근**

당신은 코딩을 바로 시작하지 않고 **아키텍처를 먼저 설계**했습니다. 특히:

- Handler, Manager, Controller의 차이를 명확히 구분하려고 한 점
- TCP/UDP 구분이 어디서 필요한지 계속 질문하며 설계를 다듬은 점
- 최종 아키텍처 수정본을 여러 번 검토받은 점

이는 **설계 우선 개발(Design-First Development)** 방식으로, 매우 좋은 습관입니다.

### **2. 코드 리뷰에 대한 적극적인 태도**

Manager 클래스들을 하나씩 작성한 후 **즉시 검증을 요청**한 점이 인상적입니다:

- UserManager의 `getEmptyGroup()` 초기화 오류를 발견할 수 있었던 것
- ProductManager의 데이터 구조 불일치 문제를 사전에 파악한 것
- 각 클래스마다 빠뜨린 기능들을 체크할 수 있었던 것

### **3. 중복 코드 발견 능력**

"clients가 필요해? Manager 내부에 이미 소켓을 저장해놨잖아"라고 질문한 부분에서 **중복을 스스로 인식**하는 좋은 감각을 보여줬습니다.

### **4. 리팩토링에 대한 개방적 사고**

RequestHandler와 ResponseHandler로 분리하자고 제안한 것은 **코드 품질을 향상시키려는 의식**을 보여줍니다. 단일 책임 원칙을 자연스럽게 적용한 사례입니다.

## **🔧 개선할 수 있는 부분들**

### **1. 요구사항 분석의 깊이**

과제 요구사항을 처음부터 **더 면밀히 분석**했다면 일부 수정 작업을 줄일 수 있었을 것입니다:

**예시**: ChatManager에서 `maxCount` 기능이 빠진 것은 snapchat 요구사항을 충분히 분석하지 못했기 때문입니다. 과제를 시작할 때 모든 요구사항을 체크리스트로 정리하는 습관을 기르면 좋겠습니다.

### **2. 데이터 모델링 일관성**

ProductManager에서 발생한 데이터 구조 불일치 문제:

```javascript
// 문제가 된 부분
this.products.set(productID, num); // 숫자 저장
this.products.set(productID, productInfo.num + num); // 객체.num 접근
```

**개선 방안**: 클래스 설계 시 먼저 **데이터 스키마를 명확히 정의**하고 주석으로 문서화하는 습관을 기르세요.

### **3. 에러 케이스 고려**

초기 구현에서 **예외 상황을 놓친 경우**가 몇 번 있었습니다:

- UserManager의 첫 번째 사용자 추가 시 그룹이 없는 상황
- 빈 Map에서 `size - 1`을 했을 때 발생하는 문제

**개선 방안**: 메서드 작성 시 **"만약 데이터가 없다면?"**을 항상 먼저 고려하는 습관을 기르세요.

### **4. 테스트 케이스 사전 계획**

구현 후 문제를 발견하는 것보다, **구현 전에 테스트 케이스를 미리 생각**해보면 더 견고한 코드를 작성할 수 있습니다:

```javascript
// 예시: UserManager 구현 전 고려해볼 테스트 케이스들
// - 첫 번째 사용자 추가
// - 4명이 가득 찬 그룹 후 새 사용자 추가
// - 존재하지 않는 사용자 삭제 시도
```

## **🚀 성장을 위한 구체적 제안**

### **1. TDD(Test-Driven Development) 도입**

다음 프로젝트에서는 구현 전에 간단한 테스트 케이스부터 작성해보세요:

```javascript
// UserManager 구현 전
test("첫 번째 사용자 추가 시 그룹 0에 할당", () => {
  // Given - When - Then 패턴으로 테스트 작성
});
```

### **2. 코드 문서화 습관**

클래스 상단에 **데이터 구조와 주요 메서드를 주석**으로 설명하는 습관을 기르세요:

```javascript
/**
 * ProductManager - 상품 정보 관리
 * 데이터 구조: { id: string, name: string, stock: number }
 * 주요 기능: 재고 관리, 상품 조회, 구매 처리
 */
```

### **3. 단계적 구현 전략**

복잡한 기능을 한 번에 구현하지 말고 **MVP(Minimum Viable Product)부터** 시작하세요:

1. 기본 기능만 먼저 구현
2. 테스트해서 동작 확인
3. 추가 기능 점진적 확대

## **🎯 종합 평가**

당신은 **설계적 사고**와 **코드 품질에 대한 의식**이 뛰어납니다. 특히 아키텍처를 계속 개선해나가는 과정에서 보여준 유연성과 학습 의지가 인상적이었습니다.

앞으로는 **요구사항 분석을 더 꼼꼼히** 하고, **예외 상황을 미리 고려**하는 습관만 기른다면 훨씬 더 견고한 소프트웨어를 개발할 수 있을 것입니다.

계속해서 이런 **"왜?"라는 질문을 던지는 자세**를 유지하시면, 단순히 동작하는 코드가 아닌 **잘 설계된 코드**를 작성하는 개발자로 성장할 것입니다!

## 느낀점

항상 테스트 코드 작성에 어려움을 느꼈는데 개발하기전에 테스트 코드를 작성하는 습관을 들이라는 부분은 실제로 적용해보려고 합니다 :smile:

</details>

### J187

선택한 미션 : Quest 1. ❓ **질문 방식 개선**
선택한 이유 : LLM을 많이 사용하지만 여태까지의 질문 방식은 이 퀘스트에서 말하는 `tcp에 대해 설명해줘` 와 같은 추상적인 질문을 했다. 질문 방식을 조금 더 구체적으로 변경한다면 답변의 품질이 나아질 지 궁금하여 선택하였다.

<details>
    <summary>수행과정 </summary>

    테스트 진행 중 모킹에 대해 궁금하여 Claude Sonnet 4를 이용해 질문을 던져보았다.

    ### 📝 1차 질문 (추상적)
    질문:
    ```
    "테스트에서 모킹이 왜 필요한지 설명해줘"
    ```
    ### 📝 2차 질문 (구체적)

    질문:

    ```
    "Jest 테스트 코드에서 jest.mock('./HttpUtil')과 jest.fn()의 차이점이 궁금해.
    내가 이해한 범위:

    jest.fn()은 가짜 함수를 만드는 것
    둘 다 실제 코드 실행을 막는다는 건 알겠음
    expect().toHaveBeenCalledWith() 같은 검증은 이해함

    이해하지 못한 부분:

    jest.mock()은 언제 사용하고 jest.fn()은 언제 사용하는지 구분 기준
    모듈 전체를 모킹하는 것과 개별 함수를 모킹하는 것의 실제 차이점
    proxyquire 같은 다른 라이브러리와의 차이점

    코드 예시와 함께 설명해줘."
    ```

    ## 🔍 답변 비교 및 분석

    ### 1차 답변 (추상적 질문에 대한 답변)

    모킹의 일반적인 개념 설명
    의존성 격리, 테스트 속도 등 일반론적 설명
    구체적인 구현 방법이나 실제 사용법은 부족할 가능성

    ### 2차 답변 (구체적 질문에 대한 답변)

    jest.mock() vs jest.fn()의 명확한 구분
    실제 코드 예시와 함께 설명
    내가 몰랐던 부분에 대한 구체적인 답변
    다른 라이브러리와의 비교까지 포함

    ## **느낀점**

    먼저 쓸데없는 답변이 없었다는점, 내가 궁금한 점에 답변이 집중된다는 점이 가장 마음에 들었다.

    ```
    "~에 대해 설명해줘"
    ```
    보다는
    ```
    ✅ "~에서 A와 B의 차이점이 궁금해.
      [이해한 범위: ...]
      [모르는 부분: ...]
      구체적으로 설명해줘"
    ```
    처럼 구체적으로 질문하는게 시간적으로도 더 나을것같다.

</details>
